<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>Metal Detector GPS Logger ‚Äì Reliable Auto‚ÄêInitialize & Resume</title>
  <style>
    /*==== (CSS unchanged from previous versions) ====*/
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI',
        sans-serif;
      background: linear-gradient(
        135deg,
        #1b5e20 0%,
        #2e7d32 50%,
        #388e3c 100%
      );
      min-height: 100vh;
      color: white;
      padding: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: manipulation;
    }
    .container {
      max-width: 420px;
      width: 100%;
      background: rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(15px);
      border-radius: 20px;
      padding: 25px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 22px;
      font-weight: 500;
      color: #e8f5e8;
    }
    .android-badge {
      text-align: center;
      background: linear-gradient(45deg, #4caf50, #8bc34a);
      padding: 10px 16px;
      border-radius: 25px;
      font-size: 14px;
      margin-bottom: 20px;
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    .status {
      text-align: center;
      margin-bottom: 20px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      font-size: 15px;
      min-height: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.4;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .voice-indicator {
      text-align: center;
      margin: 18px 0;
      font-size: 17px;
      font-weight: 500;
      padding: 14px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .listening {
      color: #ff5722;
      background: rgba(255, 87, 34, 0.2);
      animation: androidPulse 1s infinite;
      border-color: rgba(255, 87, 34, 0.4);
    }
    .ready {
      color: #4caf50;
      background: rgba(76, 175, 80, 0.2);
      border-color: rgba(76, 175, 80, 0.4);
    }
    .processing {
      color: #ff9800;
      background: rgba(255, 152, 0, 0.2);
      border-color: rgba(255, 152, 0, 0.4);
    }
    @keyframes androidPulse {
      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.8;
        transform: scale(1.05);
      }
    }
    .text-box {
      width: 100%;
      padding: 14px;
      margin: 12px 0;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      resize: vertical;
      min-height: 90px;
      line-height: 1.5;
    }
    .text-box::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }
    .text-box:focus {
      outline: none;
      border-color: #4caf50;
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3);
    }
    .text-label {
      display: block;
      margin-bottom: 6px;
      color: rgba(255, 255, 255, 0.9);
      font-size: 14px;
      font-weight: 500;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 20px;
    }
    .btn {
      padding: 16px 20px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      min-height: 56px;
      position: relative;
      overflow: hidden;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active {
      transform: scale(0.98);
      background: rgba(255, 255, 255, 0.2);
    }
    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }
    .btn.primary {
      background: linear-gradient(45deg, #4caf50, #66bb6a);
      border-color: rgba(76, 175, 80, 0.6);
      box-shadow: 0 3px 12px rgba(76, 175, 80, 0.3);
    }
    .btn.danger {
      background: linear-gradient(45deg, #f44336, #ef5350);
      border-color: rgba(244, 67, 54, 0.6);
    }
    .btn.success {
      background: linear-gradient(45deg, #2196f3, #42a5f5);
      border-color: rgba(33, 150, 243, 0.6);
    }
    .btn.merge {
      background: linear-gradient(45deg, #9c27b0, #ba68c8);
      border-color: rgba(156, 39, 176, 0.6);
      box-shadow: 0 3px 12px rgba(156, 39, 176, 0.3);
    }
    .commands {
      margin-top: 20px;
      padding: 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      font-size: 14px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .commands h3 {
      margin-bottom: 12px;
      color: #81c784;
      font-size: 16px;
    }
    .commands ul {
      list-style: none;
      padding-left: 0;
    }
    .commands li {
      margin: 8px 0;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .commands li:last-child {
      border-bottom: none;
    }
    .merge-section {
      margin-top: 25px;
      padding: 16px;
      background: rgba(156, 39, 176, 0.1);
      border-radius: 12px;
      border: 1px solid rgba(156, 39, 176, 0.3);
    }
    .merge-section h3 {
      margin-bottom: 12px;
      color: #ce93d8;
      font-size: 16px;
      text-align: center;
    }
    .merge-section p {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.8);
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .error {
      background: rgba(244, 67, 54, 0.2);
      border: 2px solid rgba(244, 67, 54, 0.5);
      color: #ffcdd2;
      margin: 12px 0;
      padding: 14px;
      border-radius: 10px;
      text-align: center;
      font-size: 14px;
      line-height: 1.4;
    }
    .success {
      background: rgba(76, 175, 80, 0.2);
      border: 2px solid rgba(76, 175, 80, 0.5);
      color: #c8e6c9;
      margin: 12px 0;
      padding: 14px;
      border-radius: 10px;
      text-align: center;
      line-height: 1.4;
    }
    .debug {
      background: rgba(255, 193, 7, 0.15);
      border: 1px solid rgba(255, 193, 7, 0.3);
      color: #fff59d;
      margin: 6px 0;
      padding: 8px;
      border-radius: 6px;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      word-break: break-word;
      line-height: 1.3;
    }
    .android-help {
      background: rgba(33, 150, 243, 0.15);
      border: 2px solid rgba(33, 150, 243, 0.4);
      color: #bbdefb;
      margin: 15px 0;
      padding: 16px;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.5;
    }
    .android-help h4 {
      color: #64b5f6;
      margin-bottom: 10px;
      font-size: 16px;
    }
    @media (max-width: 480px) {
      .container {
        padding: 20px;
        margin: 10px;
      }
      h1 {
        font-size: 20px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üîç Metal Detector GPS Logger</h1>
    <div class="android-badge">
      ü§ñ Android Optimized ‚Äì Reliable Auto‚ÄêInitialize & Resume
    </div>
    <div class="status" id="status">Initializing‚Ä¶</div>
    <div class="voice-indicator ready" id="voiceIndicator">
      üé§ Voice Commands Ready
    </div>

    <div id="coordinatesSection" style="display: none;">
      <label class="text-label">üìç GPS Coordinates:</label>
      <textarea
        id="coordinatesTextBox"
        class="text-box"
        readonly
        placeholder="Coordinates appear here after saying 'POSITION'"
      ></textarea>
    </div>

    <div id="findSection" style="display: none;">
      <label class="text-label">üèÜ Find Description:</label>
      <textarea
        id="findTextBox"
        class="text-box"
        readonly
        placeholder="Description appears here after saying 'FIND'"
      ></textarea>
    </div>

    <div id="messages"></div>

    <div class="controls">
      <button class="btn primary" id="initBtn" style="display: none;">
        üîß Initialize App
      </button>
      <button class="btn" id="startBtn" disabled>
        üé§ Start Voice Commands
      </button>
      <button class="btn danger" id="stopBtn" disabled>‚èπÔ∏è Stop Listening</button>
      <!-- Hidden manual download button; auto‚Äêdownload on FINISH -->
      <button class="btn success" id="downloadBtn" style="display: none;">
        üì• Download KML
      </button>
    </div>

    <div class="commands">
      <h3>üó£Ô∏è Voice Commands:</h3>
      <ul>
        <li><strong>"POSITION"</strong> ‚Äì Record GPS coordinates</li>
        <li><strong>"FIND [description]"</strong> ‚Äì Record find details</li>
        <li>
          <strong>"FINISH"</strong> ‚Äì Auto-download one KML containing all points
        </li>
      </ul>
    </div>

    <div class="merge-section">
      <h3>üîó KML File Merger</h3>
      <p>Auto-scan Downloads directory OR manually select KML files to merge into a single cumulative file</p>
      <button class="btn merge" id="mergeBtn">
        üîó MERGE TODAY'S KML FILES
      </button>
    </div>
  </div>

  <script>
    class AndroidMetalDetectorLogger {
      constructor() {
        // Speech, audio, and GPS state
        this.recognition = null;
        this.audioContext = null;
        this.isListening = false;
        this.isInitialized = false;
        this.startAttempts = 0;
        this.maxStartAttempts = 3;
        this.recognitionTimeout = null;
        this.debugMode = true;

        // Temporary store for last GPS fix
        this.currentPosition = null;

        // Array of logged points
        this.places = [];

        // KML blob + filename (for FINISH)
        this.kmlBlob = null;
        this.kmlFilename = '';

        // UI elements
        this.statusEl = null;
        this.voiceIndicatorEl = null;
        this.coordinatesSectionEl = null;
        this.coordinatesTextBoxEl = null;
        this.findSectionEl = null;
        this.findTextBoxEl = null;
        this.messagesEl = null;
        this.initBtn = null;
        this.startBtn = null;
        this.stopBtn = null;
        this.downloadBtn = null;
        this.mergeBtn = null;

        // State: 'waiting' ‚Üí after POSITION ‚Üí 'logged' ‚Üí after FIND ‚Üí 'readyToFinish'
        this.currentStep = 'waiting';

        this.initElements();
        this.detectAndroid();
        this.initEventListeners();
        
        // Attempt auto-initialization, but don't fail if it doesn't work
        setTimeout(() => this.attemptAutoInit(), 500);
      }

      /***** UI SETUP *****/
      initElements() {
        this.statusEl = document.getElementById('status');
        this.voiceIndicatorEl = document.getElementById('voiceIndicator');
        this.coordinatesSectionEl = document.getElementById(
          'coordinatesSection'
        );
        this.coordinatesTextBoxEl = document.getElementById('coordinatesTextBox');
        this.findSectionEl = document.getElementById('findSection');
        this.findTextBoxEl = document.getElementById('findTextBox');
        this.messagesEl = document.getElementById('messages');
        this.initBtn = document.getElementById('initBtn');
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.mergeBtn = document.getElementById('mergeBtn');
      }

      detectAndroid() {
        const ua = navigator.userAgent.toLowerCase();
        const isAndroid = /android/.test(ua);
        const isChrome = /chrome/.test(ua) && !/edg/.test(ua);
        this.debugLog('Android detected: ' + isAndroid);
        this.debugLog('Chrome detected: ' + isChrome);

        if (isAndroid) {
          this.updateStatus(
            isChrome
              ? 'ü§ñ Android Chrome detected ‚Äì Excellent compatibility!'
              : 'ü§ñ Android detected ‚Äì Chrome recommended'
          );
        } else {
          this.updateStatus('‚ö†Ô∏è Optimized for Android');
        }
      }

      initEventListeners() {
        this.initBtn.addEventListener('click', () => this.initializeApp());
        this.startBtn.addEventListener('click', () => this.startListening());
        this.stopBtn.addEventListener('click', () => this.stopListening());
        this.downloadBtn.addEventListener('click', () => this.downloadKML());
        this.mergeBtn.addEventListener('click', () => this.mergeKMLFiles());

        // Resume AudioContext on any tap/click
        document.addEventListener('click', () => this.resumeAudioContext(), {
          once: true,
        });
        document.addEventListener('touchstart', () => this.resumeAudioContext(), {
          once: true,
        });

        // 1) visibilitychange: only to stop listening when hidden
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            if (this.isListening) {
              this.stopListening();
            }
          }
          // We do NOT attempt to re‚Äêinitialize here
        });

        // 2) focus: fired when the window/tab regains focus (Android unlock, returning to Chrome)
        window.addEventListener('focus', () => {
          if (!this.isInitialized) {
            // If never initialized (first time, or page fully suspended without init), do it now
            this.initializeApp();
          } else {
            // Already initialized ‚Üí stop old recognition, recreate, and start listening
            if (this.isListening) {
              this.stopListening();
            }
            this.initSpeechRecognition();
            this.startListening();
          }
        });

        // 3) pageshow: covers restoration from bfcache
        window.addEventListener('pageshow', (evt) => {
          if (evt.persisted) {
            if (!this.isInitialized) {
              this.initializeApp();
            } else {
              if (this.isListening) {
                this.stopListening();
              }
              this.initSpeechRecognition();
              this.startListening();
            }
          }
        });
      }

      async resumeAudioContext() {
        if (this.audioContext && this.audioContext.state === 'suspended') {
          try {
            await this.audioContext.resume();
            this.debugLog('‚úÖ Audio context resumed');
          } catch (err) {
            this.debugLog('‚ö†Ô∏è Audio resume failed: ' + err.message);
          }
        }
      }

      async attemptAutoInit() {
        this.debugLog('üîÑ Attempting automatic initialization...');
        try {
          await this.initializeApp();
        } catch (err) {
          this.debugLog('‚ö†Ô∏è Auto-initialization failed: ' + err.message);
          this.updateStatus('‚ö†Ô∏è Click "Initialize App" to set up voice commands');
          this.initBtn.style.display = 'block';
          this.showError('Auto-initialization failed. Click "Initialize App" to try again.');
        }
      }

      /***** INITIALIZATION FLOW *****/
      async initializeApp() {
        this.debugLog('üöÄ Starting app initialization...');
        this.messagesEl.innerHTML = ''; // clear old messages
        this.updateStatus('üîß Checking browser compatibility...');

        // Step 1: Check API support
        if (!this.checkAPIsupport()) {
          this.updateStatus('‚ùå Browser compatibility issues detected');
          this.showAndroidHelp();
          return;
        }

        this.updateStatus('üé§ Requesting microphone permission...');
        this.debugLog('‚úÖ API support check passed');

        // Step 2: Request permissions with better error handling
        try {
          await this.requestPermissions();
          this.debugLog('‚úÖ Microphone permission granted');
        } catch (err) {
          this.debugLog('‚ùå Permission request failed: ' + err.message);
          this.updateStatus('‚ùå Microphone permission denied');
          this.showError('Microphone access required. Please enable in browser settings.');
          this.showAndroidHelp();
          // Don't return - continue with limited functionality
        }

        // Step 3: Initialize audio context
        this.updateStatus('üîä Setting up audio system...');
        try {
          await this.initAudioContext();
          this.debugLog('‚úÖ Audio context initialized');
        } catch (err) {
          this.debugLog('‚ö†Ô∏è Audio context failed: ' + err.message);
          // Continue without audio feedback
        }

        // Step 4: Initialize speech recognition
        this.updateStatus('üó£Ô∏è Setting up voice recognition...');
        try {
          this.initSpeechRecognition();
          if (this.recognition) {
            this.debugLog('‚úÖ Speech recognition initialized');
          } else {
            throw new Error('Speech recognition not available');
          }
        } catch (err) {
          this.debugLog('‚ùå Speech recognition failed: ' + err.message);
          this.updateStatus('‚ùå Voice recognition setup failed');
          this.showError('Voice recognition not available. Check browser compatibility.');
          this.showAndroidHelp();
          this.initBtn.style.display = 'block'; // Show manual retry button
          this.isInitialized = false;
          return;
        }

        // Step 5: Finalize initialization
        this.isInitialized = true;
        this.initBtn.style.display = 'none'; // Hide manual init button
        this.startBtn.disabled = false;
        this.updateStatus('‚úÖ App ready! Click "Start Voice Commands"');
        this.debugLog('üéâ Initialization completed successfully');
        this.showSuccess('üéâ App ready! Click "Start Voice Commands" to begin.');
        
        // Auto-start listening after a brief delay
        setTimeout(() => {
          if (this.isInitialized && !this.isListening) {
            this.debugLog('üîÑ Auto-starting voice commands...');
            this.startListening();
          }
        }, 1500);
      }

      checkAPIsupport() {
        const issues = [];
        const warnings = [];
        
        // Check Speech Recognition
        if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
          issues.push('Speech Recognition not available');
        } else {
          this.debugLog('‚úÖ Speech Recognition API available');
        }
        
        // Check Microphone API
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          issues.push('Microphone API not supported');
        } else {
          this.debugLog('‚úÖ Microphone API available');
        }
        
        // Check Geolocation
        if (!navigator.geolocation) {
          issues.push('GPS not available');
        } else {
          this.debugLog('‚úÖ Geolocation API available');
        }
        
        // Check HTTPS requirement
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
          issues.push('HTTPS required for microphone access');
        } else {
          this.debugLog('‚úÖ Secure context verified');
        }
        
        // Check browser type
        const ua = navigator.userAgent.toLowerCase();
        const isChrome = /chrome/.test(ua) && !/edg/.test(ua);
        const isBrave = /chrome/.test(ua) && /brave/.test(ua);
        const isAndroid = /android/.test(ua);
        
        if (!isChrome && !isBrave) {
          warnings.push('Chrome or Brave browser recommended');
        }
        
        this.debugLog(`Browser detection - Chrome: ${isChrome}, Brave: ${isBrave}, Android: ${isAndroid}`);

        if (issues.length) {
          this.showError('‚ö†Ô∏è Critical issues: ' + issues.join(', '));
          if (warnings.length) {
            this.showError('‚ö†Ô∏è Recommendations: ' + warnings.join(', '));
          }
          return false;
        }
        
        if (warnings.length) {
          warnings.forEach(warning => this.debugLog('‚ö†Ô∏è ' + warning));
        }
        
        return true;
      }

      async requestPermissions() {
        this.debugLog('üîê Requesting microphone permission...');
        
        try {
          // Test microphone access with a short-lived stream
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });
          
          // Stop tracks immediately; we just needed the permission prompt
          stream.getTracks().forEach((t) => t.stop());
          this.debugLog('‚úÖ Microphone permission granted');
          return true;
          
        } catch (err) {
          this.debugLog('‚ùå Microphone permission error: ' + err.name + ' - ' + err.message);
          
          // Provide specific error messages based on error type
          if (err.name === 'NotAllowedError') {
            throw new Error('Microphone access denied by user. Please enable in browser settings.');
          } else if (err.name === 'NotFoundError') {
            throw new Error('No microphone found. Please connect a microphone.');
          } else if (err.name === 'NotReadableError') {
            throw new Error('Microphone is busy or being used by another application.');
          } else if (err.name === 'OverconstrainedError') {
            throw new Error('Microphone constraints not supported.');
          } else if (err.name === 'SecurityError') {
            throw new Error('Microphone access blocked due to security restrictions.');
          } else {
            throw new Error('Microphone access failed: ' + err.message);
          }
        }
      }

      async initAudioContext() {
        try {
          const AC = window.AudioContext || window.webkitAudioContext;
          this.audioContext = new AC();
          this.debugLog('‚úÖ Audio context created');
        } catch (err) {
          this.debugLog('‚ö†Ô∏è Audio context error: ' + err.message);
        }
      }

      /***** SPEECH RECOGNITION SETUP (now inside initializeApp) *****/
      initSpeechRecognition() {
        // If a previous recognition exists, tear it down first
        if (this.recognition) {
          try {
            this.recognition.onresult = null;
            this.recognition.onerror = null;
            this.recognition.onstart = null;
            this.recognition.onend = null;
            this.recognition = null;
          } catch {}
        }

        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.recognition = SR ? new SR() : null;
        if (!this.recognition) return;

        this.recognition.continuous = true;
        this.recognition.interimResults = false;
        this.recognition.lang = 'en-US';
        this.recognition.maxAlternatives = 1;

        this.recognition.onstart = () => {
          this.isListening = true;
          this.startAttempts = 0;
          this.updateVoiceIndicator('listening');
          this.startBtn.disabled = true;
          this.stopBtn.disabled = false;
        };

        this.recognition.onend = () => {
          this.isListening = false;
          this.updateVoiceIndicator('ready');
          this.startBtn.disabled = false;
          this.stopBtn.disabled = true;
          // Auto‚Äêrestart if not finished
          if (
            this.currentStep !== 'finished' &&
            this.isInitialized &&
            this.startAttempts < this.maxStartAttempts
          ) {
            this.recognitionTimeout = setTimeout(() => this.startListening(), 1500);
          }
        };

        this.recognition.onresult = (evt) => {
          const lastResult = evt.results[evt.results.length - 1];
          if (lastResult.isFinal) {
            const transcript = lastResult[0].transcript.trim();
            this.processVoiceCommand(transcript);
          }
        };

        this.recognition.onerror = (evt) => {
          this.debugLog('Speech error: ' + evt.error);
          if (evt.error === 'not-allowed') {
            this.showError('‚ùå Microphone blocked! Enable in browser settings.');
            this.isInitialized = false;
          } else if (evt.error === 'audio-capture') {
            this.showError('‚ùå Microphone busy. Close other apps.');
          }
        };
      }

      startListening() {
        if (!this.isInitialized) {
          this.showError('Please initialize first');
          return;
        }
        if (!this.recognition) {
          // If recognition wasn't created for some reason, create it now
          this.initSpeechRecognition();
          if (!this.recognition) {
            this.showError('SpeechRecognition unavailable');
            return;
          }
        }
        if (this.isListening) return;
        if (this.startAttempts >= this.maxStartAttempts) {
          this.showError('Too many attempts. Refresh the page.');
          return;
        }
        try {
          this.startAttempts++;
          this.recognition.start();
          this.updateStatus('üé§ Listening‚Ä¶ Say commands');
        } catch (err) {
          this.debugLog('Start error: ' + err.message);
        }
      }

      stopListening() {
        if (this.recognition && this.isListening) {
          this.recognition.stop();
          if (this.recognitionTimeout) clearTimeout(this.recognitionTimeout);
          this.updateStatus('üîá Recognition stopped');
          this.startAttempts = 0;
        }
      }

      /***** VOICE COMMAND HANDLING *****/
      processVoiceCommand(command) {
        const lower = command.toLowerCase();
        this.debugLog('Heard: ' + command);

        if (lower.includes('position')) {
          this.handlePositionCommand();
        } else if (lower.includes('find')) {
          this.handleFindCommand(lower);
        } else if (lower.includes('finish')) {
          this.handleFinishCommand();
        } else {
          this.updateStatus('Say: POSITION, FIND [desc], or FINISH');
        }
      }

      handlePositionCommand() {
        if (!this.isInitialized) {
          this.showError('Please initialize first');
          return;
        }
        this.updateStatus('üìç Getting GPS‚Ä¶');
        this.updateVoiceIndicator('processing');

        navigator.geolocation.getCurrentPosition(
          (pos) => {
            this.currentPosition = {
              lat: pos.coords.latitude,
              lng: pos.coords.longitude,
              accuracy: pos.coords.accuracy,
              timestamp: new Date(),
            };
            this.displayCoordinates();
            this.playBeep();
            this.currentStep = 'logged';
            this.updateStatus('‚úÖ Position fixed! Say "FIND [description]"');
            this.updateVoiceIndicator('ready');
          },
          (err) => {
            this.showError('GPS failed: ' + this.getGPSErrorMessage(err));
            this.updateVoiceIndicator('ready');
          },
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
        );
      }

      getGPSErrorMessage(error) {
        switch (error.code) {
          case error.PERMISSION_DENIED:
            return 'Location denied. Enable location in settings.';
          case error.POSITION_UNAVAILABLE:
            return 'GPS unavailable. Move to open area.';
          case error.TIMEOUT:
            return 'GPS timeout. Try again.';
          default:
            return 'GPS error. Check settings.';
        }
      }

      handleFindCommand(command) {
        if (this.currentStep !== 'logged') {
          this.showError('‚ùå Say "POSITION" first');
          return;
        }
        const desc = command.substring(command.indexOf('find') + 4).trim();
        if (!desc) {
          this.updateStatus('Say "FIND" followed by your description');
          return;
        }
        // Save this point + description
        const entry = {
          lat: this.currentPosition.lat,
          lng: this.currentPosition.lng,
          accuracy: this.currentPosition.accuracy,
          timestamp: this.currentPosition.timestamp,
          description: desc,
        };
        this.places.push(entry);

        // Update UI
        this.findTextBoxEl.value = desc;
        this.findSectionEl.style.display = 'block';

        this.currentPosition = null;
        this.currentStep = 'readyToFinish';
        this.updateStatus('‚úÖ Description recorded! Say "FINISH"');
      }

      handleFinishCommand() {
        if (this.places.length === 0) {
          this.showError('‚ùå No points logged yet');
          return;
        }
        this.generateCombinedKML();
        this.currentStep = 'finished';
        this.stopListening();
        this.updateStatus('‚úÖ Generating & downloading cumulative KML‚Ä¶');
        this.downloadKML();
        this.playCompletionTone();
      }

      displayCoordinates() {
        const c = this.currentPosition;
        const text = `Latitude: ${c.lat.toFixed(8)}
Longitude: ${c.lng.toFixed(8)}
Accuracy: ¬±${c.accuracy.toFixed(1)}m
Time: ${c.timestamp.toLocaleString()}`;
        this.coordinatesTextBoxEl.value = text;
        this.coordinatesSectionEl.style.display = 'block';
      }

      generateCombinedKML() {
        const now = new Date();
        const datePrefix = now.toISOString().split('T')[0];
        const timeOfDay = now.toTimeString().split(' ')[0].replace(/:/g, '');
        this.kmlFilename = `${datePrefix}_cumulative_${timeOfDay}.kml`;

        let placemarks = '';
        this.places.forEach((p) => {
          const firstWord = p.description
            .split(' ')[0]
            .replace(/[^a-zA-Z0-9]/g, '') || 'find';
          const timestampStr = p.timestamp.toLocaleString();
          const descriptionEscaped = p.description
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          const tsEscaped = timestampStr
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

          placemarks += `
    <Placemark>
      <name>${firstWord}</name>
      <description>${descriptionEscaped}&#10;${tsEscaped}</description>
      <Point><coordinates>${p.lng},${p.lat},0</coordinates></Point>
    </Placemark>`;
        });

        const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Metal Detector Finds (Cumulative)</name>${placemarks}
  </Document>
</kml>`;

        this.kmlBlob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
      }

      downloadKML() {
        if (!this.kmlBlob) {
          this.showError('‚ùå No KML to download');
          return;
        }
        const url = URL.createObjectURL(this.kmlBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.kmlFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.showSuccess('üì• Download triggered: ' + this.kmlFilename);
        // We do NOT clear places[], so a later "FINISH" still accumulates all points again.
      }

      /***** NEW KML MERGE FUNCTIONALITY *****/
      async mergeKMLFiles() {
        this.debugLog('üîó Starting KML merge process...');
        
        // Enhanced API support detection
        const hasDirectoryAPI = 'showDirectoryPicker' in window && window.isSecureContext;
        const hasFileAPI = 'showOpenFilePicker' in window && window.isSecureContext;
        
        this.debugLog(`Directory API available: ${hasDirectoryAPI}`);
        this.debugLog(`File API available: ${hasFileAPI}`);
        this.debugLog(`Secure context: ${window.isSecureContext}`);
        this.debugLog(`Protocol: ${window.location.protocol}`);
        
        if (!hasDirectoryAPI && !hasFileAPI) {
          this.showError('‚ùå File System Access API not supported. Requires HTTPS and Chrome/Brave browser.');
          this.debugLog('‚ùå Neither showDirectoryPicker nor showOpenFilePicker available');
          return;
        }

        // Try directory picker first, fallback to file picker
        if (hasDirectoryAPI) {
          await this.mergeFromDirectory();
        } else if (hasFileAPI) {
          await this.mergeFromFileSelection();
        }
      }

      async mergeFromDirectory() {

        try {
          // Get today's date for filtering files
          const today = new Date();
          const todayDateStr = today.toISOString().split('T')[0]; // YYYY-MM-DD format
          
          this.updateStatus('üìÇ Requesting Downloads directory access...');
          
          // Request access to Downloads directory
          let directoryHandle;
          try {
            // Try to access the Downloads directory directly
            directoryHandle = await window.showDirectoryPicker({
              id: 'downloads',
              startIn: 'downloads'
            });
          } catch (err) {
            if (err.name === 'AbortError') {
              this.updateStatus('‚ùå Directory access cancelled');
              return;
            }
            // If directory picker fails, try file picker fallback
            this.debugLog('‚ö†Ô∏è Directory picker failed, trying file picker: ' + err.message);
            await this.mergeFromFileSelection();
            return;
          }

          this.debugLog('‚úÖ Directory access granted: ' + directoryHandle.name);
          this.updateStatus('üîç Scanning for today\'s KML files...');

          // Scan for KML files matching today's pattern
          const kmlFiles = [];
          const filePattern = new RegExp(`^${todayDateStr}_cumulative_\\d{6}\\.kml<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>Metal Detector GPS Logger ‚Äì Reliable Auto‚ÄêInitialize & Resume</title>
  <style>
    /*==== (CSS unchanged from previous versions) ====*/
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI',
        sans-serif;
      background: linear-gradient(
        135deg,
        #1b5e20 0%,
        #2e7d32 50%,
        #388e3c 100%
      );
      min-height: 100vh;
      color: white;
      padding: 15px;
      display: flex;
      flex-direction: column;
      align-items: center;
      touch-action: manipulation;
    }
    .container {
      max-width: 420px;
      width: 100%;
      background: rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(15px);
      border-radius: 20px;
      padding: 25px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 22px;
      font-weight: 500;
      color: #e8f5e8;
    }
    .android-badge {
      text-align: center;
      background: linear-gradient(45deg, #4caf50, #8bc34a);
      padding: 10px 16px;
      border-radius: 25px;
      font-size: 14px;
      margin-bottom: 20px;
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    .status {
      text-align: center;
      margin-bottom: 20px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      font-size: 15px;
      min-height: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1.4;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .voice-indicator {
      text-align: center;
      margin: 18px 0;
      font-size: 17px;
      font-weight: 500;
      padding: 14px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .listening {
      color: #ff5722;
      background: rgba(255, 87, 34, 0.2);
      animation: androidPulse 1s infinite;
      border-color: rgba(255, 87, 34, 0.4);
    }
    .ready {
      color: #4caf50;
      background: rgba(76, 175, 80, 0.2);
      border-color: rgba(76, 175, 80, 0.4);
    }
    .processing {
      color: #ff9800;
      background: rgba(255, 152, 0, 0.2);
      border-color: rgba(255, 152, 0, 0.4);
    }
    @keyframes androidPulse {
      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.8;
        transform: scale(1.05);
      }
    }
    .text-box {
      width: 100%;
      padding: 14px;
      margin: 12px 0;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      resize: vertical;
      min-height: 90px;
      line-height: 1.5;
    }
    .text-box::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }
    .text-box:focus {
      outline: none;
      border-color: #4caf50;
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3);
    }
    .text-label {
      display: block;
      margin-bottom: 6px;
      color: rgba(255, 255, 255, 0.9);
      font-size: 14px;
      font-weight: 500;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 20px;
    }
    .btn {
      padding: 16px 20px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      background: rgba(255, 255, 255, 0.15);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.3);
      min-height: 56px;
      position: relative;
      overflow: hidden;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active {
      transform: scale(0.98);
      background: rgba(255, 255, 255, 0.2);
    }
    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }
    .btn.primary {
      background: linear-gradient(45deg, #4caf50, #66bb6a);
      border-color: rgba(76, 175, 80, 0.6);
      box-shadow: 0 3px 12px rgba(76, 175, 80, 0.3);
    }
    .btn.danger {
      background: linear-gradient(45deg, #f44336, #ef5350);
      border-color: rgba(244, 67, 54, 0.6);
    }
    .btn.success {
      background: linear-gradient(45deg, #2196f3, #42a5f5);
      border-color: rgba(33, 150, 243, 0.6);
    }
    .btn.merge {
      background: linear-gradient(45deg, #9c27b0, #ba68c8);
      border-color: rgba(156, 39, 176, 0.6);
      box-shadow: 0 3px 12px rgba(156, 39, 176, 0.3);
    }
    .commands {
      margin-top: 20px;
      padding: 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      font-size: 14px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    .commands h3 {
      margin-bottom: 12px;
      color: #81c784;
      font-size: 16px;
    }
    .commands ul {
      list-style: none;
      padding-left: 0;
    }
    .commands li {
      margin: 8px 0;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .commands li:last-child {
      border-bottom: none;
    }
    .merge-section {
      margin-top: 25px;
      padding: 16px;
      background: rgba(156, 39, 176, 0.1);
      border-radius: 12px;
      border: 1px solid rgba(156, 39, 176, 0.3);
    }
    .merge-section h3 {
      margin-bottom: 12px;
      color: #ce93d8;
      font-size: 16px;
      text-align: center;
    }
    .merge-section p {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.8);
      text-align: center;
      margin-bottom: 15px;
      line-height: 1.4;
    }
    .error {
      background: rgba(244, 67, 54, 0.2);
      border: 2px solid rgba(244, 67, 54, 0.5);
      color: #ffcdd2;
      margin: 12px 0;
      padding: 14px;
      border-radius: 10px;
      text-align: center;
      font-size: 14px;
      line-height: 1.4;
    }
    .success {
      background: rgba(76, 175, 80, 0.2);
      border: 2px solid rgba(76, 175, 80, 0.5);
      color: #c8e6c9;
      margin: 12px 0;
      padding: 14px;
      border-radius: 10px;
      text-align: center;
      line-height: 1.4;
    }
    .debug {
      background: rgba(255, 193, 7, 0.15);
      border: 1px solid rgba(255, 193, 7, 0.3);
      color: #fff59d;
      margin: 6px 0;
      padding: 8px;
      border-radius: 6px;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      word-break: break-word;
      line-height: 1.3;
    }
    .android-help {
      background: rgba(33, 150, 243, 0.15);
      border: 2px solid rgba(33, 150, 243, 0.4);
      color: #bbdefb;
      margin: 15px 0;
      padding: 16px;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.5;
    }
    .android-help h4 {
      color: #64b5f6;
      margin-bottom: 10px;
      font-size: 16px;
    }
    @media (max-width: 480px) {
      .container {
        padding: 20px;
        margin: 10px;
      }
      h1 {
        font-size: 20px;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>üîç Metal Detector GPS Logger</h1>
    <div class="android-badge">
      ü§ñ Android Optimized ‚Äì Reliable Auto‚ÄêInitialize & Resume
    </div>
    <div class="status" id="status">Initializing‚Ä¶</div>
    <div class="voice-indicator ready" id="voiceIndicator">
      üé§ Voice Commands Ready
    </div>

    <div id="coordinatesSection" style="display: none;">
      <label class="text-label">üìç GPS Coordinates:</label>
      <textarea
        id="coordinatesTextBox"
        class="text-box"
        readonly
        placeholder="Coordinates appear here after saying 'POSITION'"
      ></textarea>
    </div>

    <div id="findSection" style="display: none;">
      <label class="text-label">üèÜ Find Description:</label>
      <textarea
        id="findTextBox"
        class="text-box"
        readonly
        placeholder="Description appears here after saying 'FIND'"
      ></textarea>
    </div>

    <div id="messages"></div>

    <div class="controls">
      <button class="btn" id="startBtn" disabled>
        üé§ Start Voice Commands
      </button>
      <button class="btn danger" id="stopBtn" disabled>‚èπÔ∏è Stop Listening</button>
      <!-- Hidden manual download button; auto‚Äêdownload on FINISH -->
      <button class="btn success" id="downloadBtn" style="display: none;">
        üì• Download KML
      </button>
    </div>

    <div class="commands">
      <h3>üó£Ô∏è Voice Commands:</h3>
      <ul>
        <li><strong>"POSITION"</strong> ‚Äì Record GPS coordinates</li>
        <li><strong>"FIND [description]"</strong> ‚Äì Record find details</li>
        <li>
          <strong>"FINISH"</strong> ‚Äì Auto-download one KML containing all points
        </li>
      </ul>
    </div>

    <div class="merge-section">
      <h3>üîó KML File Merger</h3>
      <p>Merge all today's KML files from Downloads directory into a single cumulative file</p>
      <button class="btn merge" id="mergeBtn">
        üîó MERGE TODAY'S KML FILES
      </button>
    </div>
  </div>

  <script>
    class AndroidMetalDetectorLogger {
      constructor() {
        // Speech, audio, and GPS state
        this.recognition = null;
        this.audioContext = null;
        this.isListening = false;
        this.isInitialized = false;
        this.startAttempts = 0;
        this.maxStartAttempts = 3;
        this.recognitionTimeout = null;
        this.debugMode = true;

        // Temporary store for last GPS fix
        this.currentPosition = null;

        // Array of logged points
        this.places = [];

        // KML blob + filename (for FINISH)
        this.kmlBlob = null;
        this.kmlFilename = '';

        // UI elements
        this.statusEl = null;
        this.voiceIndicatorEl = null;
        this.coordinatesSectionEl = null;
        this.coordinatesTextBoxEl = null;
        this.findSectionEl = null;
        this.findTextBoxEl = null;
        this.messagesEl = null;
        this.startBtn = null;
        this.stopBtn = null;
        this.downloadBtn = null;
        this.mergeBtn = null;

        // State: 'waiting' ‚Üí after POSITION ‚Üí 'logged' ‚Üí after FIND ‚Üí 'readyToFinish'
        this.currentStep = 'waiting';

        this.initElements();
        this.detectAndroid();
        // NOTE: We do NOT call initSpeechRecognition() here
        this.initEventListeners();
      }

      /***** UI SETUP *****/
      initElements() {
        this.statusEl = document.getElementById('status');
        this.voiceIndicatorEl = document.getElementById('voiceIndicator');
        this.coordinatesSectionEl = document.getElementById(
          'coordinatesSection'
        );
        this.coordinatesTextBoxEl = document.getElementById('coordinatesTextBox');
        this.findSectionEl = document.getElementById('findSection');
        this.findTextBoxEl = document.getElementById('findTextBox');
        this.messagesEl = document.getElementById('messages');
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.downloadBtn = document.getElementById('downloadBtn');
        this.mergeBtn = document.getElementById('mergeBtn');
      }

      detectAndroid() {
        const ua = navigator.userAgent.toLowerCase();
        const isAndroid = /android/.test(ua);
        const isChrome = /chrome/.test(ua) && !/edg/.test(ua);
        this.debugLog('Android detected: ' + isAndroid);
        this.debugLog('Chrome detected: ' + isChrome);

        if (isAndroid) {
          this.updateStatus(
            isChrome
              ? 'ü§ñ Android Chrome detected ‚Äì Excellent compatibility!'
              : 'ü§ñ Android detected ‚Äì Chrome recommended'
          );
        } else {
          this.updateStatus('‚ö†Ô∏è Optimized for Android');
        }
      }

      initEventListeners() {
        this.startBtn.addEventListener('click', () => this.startListening());
        this.stopBtn.addEventListener('click', () => this.stopListening());
        this.downloadBtn.addEventListener('click', () => this.downloadKML());
        this.mergeBtn.addEventListener('click', () => this.mergeKMLFiles());

        // Resume AudioContext on any tap/click
        document.addEventListener('click', () => this.resumeAudioContext(), {
          once: true,
        });
        document.addEventListener('touchstart', () => this.resumeAudioContext(), {
          once: true,
        });

        // 1) visibilitychange: only to stop listening when hidden
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            if (this.isListening) {
              this.stopListening();
            }
          }
          // We do NOT attempt to re‚Äêinitialize here
        });

        // 2) focus: fired when the window/tab regains focus (Android unlock, returning to Chrome)
        window.addEventListener('focus', () => {
          if (!this.isInitialized) {
            // If never initialized (first time, or page fully suspended without init), do it now
            this.initializeApp();
          } else {
            // Already initialized ‚Üí stop old recognition, recreate, and start listening
            if (this.isListening) {
              this.stopListening();
            }
            this.initSpeechRecognition();
            this.startListening();
          }
        });

        // 3) pageshow: covers restoration from bfcache
        window.addEventListener('pageshow', (evt) => {
          if (evt.persisted) {
            if (!this.isInitialized) {
              this.initializeApp();
            } else {
              if (this.isListening) {
                this.stopListening();
              }
              this.initSpeechRecognition();
              this.startListening();
            }
          }
        });
      }

      async resumeAudioContext() {
        if (this.audioContext && this.audioContext.state === 'suspended') {
          try {
            await this.audioContext.resume();
            this.debugLog('‚úÖ Audio context resumed');
          } catch (err) {
            this.debugLog('‚ö†Ô∏è Audio resume failed: ' + err.message);
          }
        }
      }

      /***** INITIALIZATION FLOW *****/
      async initializeApp() {
        this.debugLog('Auto‚Äêinitializing app‚Ä¶');
        this.messagesEl.innerHTML = ''; // clear old messages

        if (!this.checkAPIsupport()) return;

        try {
          await this.requestPermissions();
        } catch (err) {
          this.showError('Setup failed: ' + err.message);
          this.showAndroidHelp();
          return;
        }

        await this.initAudioContext();

        // Now that AudioContext exists, create a new SpeechRecognition instance
        this.initSpeechRecognition();

        this.isInitialized = true;

        // Enable "Start Voice Commands" and immediately start listening
        this.startBtn.disabled = false;
        this.updateStatus('‚úÖ App ready! Awaiting "POSITION"');
        this.showSuccess('üéâ Listening for "POSITION" now.');
        this.startListening();
      }

      checkAPIsupport() {
        const issues = [];
        if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
          issues.push('Speech Recognition not available');
        }
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          issues.push('Microphone API not supported');
        }
        if (!navigator.geolocation) {
          issues.push('GPS not available');
        }
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
          issues.push('HTTPS required for microphone');
        }

        if (issues.length) {
          this.showError('‚ö†Ô∏è ' + issues.join(', '));
          return false;
        }
        return true;
      }

      async requestPermissions() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });
          // Stop tracks immediately; we just needed the permission prompt
          stream.getTracks().forEach((t) => t.stop());
          this.debugLog('‚úÖ Microphone permission granted');
        } catch (err) {
          this.debugLog('‚ùå Microphone permission failed: ' + err.message);
          throw new Error('Microphone access denied');
        }
      }

      async initAudioContext() {
        try {
          const AC = window.AudioContext || window.webkitAudioContext;
          this.audioContext = new AC();
          this.debugLog('‚úÖ Audio context created');
        } catch (err) {
          this.debugLog('‚ö†Ô∏è Audio context error: ' + err.message);
        }
      }

      /***** SPEECH RECOGNITION SETUP (now inside initializeApp) *****/
      initSpeechRecognition() {
        // If a previous recognition exists, tear it down first
        if (this.recognition) {
          try {
            this.recognition.onresult = null;
            this.recognition.onerror = null;
            this.recognition.onstart = null;
            this.recognition.onend = null;
            this.recognition = null;
          } catch {}
        }

        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        this.recognition = SR ? new SR() : null;
        if (!this.recognition) return;

        this.recognition.continuous = true;
        this.recognition.interimResults = false;
        this.recognition.lang = 'en-US';
        this.recognition.maxAlternatives = 1;

        this.recognition.onstart = () => {
          this.isListening = true;
          this.startAttempts = 0;
          this.updateVoiceIndicator('listening');
          this.startBtn.disabled = true;
          this.stopBtn.disabled = false;
        };

        this.recognition.onend = () => {
          this.isListening = false;
          this.updateVoiceIndicator('ready');
          this.startBtn.disabled = false;
          this.stopBtn.disabled = true;
          // Auto‚Äêrestart if not finished
          if (
            this.currentStep !== 'finished' &&
            this.isInitialized &&
            this.startAttempts < this.maxStartAttempts
          ) {
            this.recognitionTimeout = setTimeout(() => this.startListening(), 1500);
          }
        };

        this.recognition.onresult = (evt) => {
          const lastResult = evt.results[evt.results.length - 1];
          if (lastResult.isFinal) {
            const transcript = lastResult[0].transcript.trim();
            this.processVoiceCommand(transcript);
          }
        };

        this.recognition.onerror = (evt) => {
          this.debugLog('Speech error: ' + evt.error);
          if (evt.error === 'not-allowed') {
            this.showError('‚ùå Microphone blocked! Enable in browser settings.');
            this.isInitialized = false;
          } else if (evt.error === 'audio-capture') {
            this.showError('‚ùå Microphone busy. Close other apps.');
          }
        };
      }

      startListening() {
        if (!this.isInitialized) {
          this.showError('Please initialize first');
          return;
        }
        if (!this.recognition) {
          // If recognition wasn't created for some reason, create it now
          this.initSpeechRecognition();
          if (!this.recognition) {
            this.showError('SpeechRecognition unavailable');
            return;
          }
        }
        if (this.isListening) return;
        if (this.startAttempts >= this.maxStartAttempts) {
          this.showError('Too many attempts. Refresh the page.');
          return;
        }
        try {
          this.startAttempts++;
          this.recognition.start();
          this.updateStatus('üé§ Listening‚Ä¶ Say commands');
        } catch (err) {
          this.debugLog('Start error: ' + err.message);
        }
      }

      stopListening() {
        if (this.recognition && this.isListening) {
          this.recognition.stop();
          if (this.recognitionTimeout) clearTimeout(this.recognitionTimeout);
          this.updateStatus('üîá Recognition stopped');
          this.startAttempts = 0;
        }
      }

      /***** VOICE COMMAND HANDLING *****/
      processVoiceCommand(command) {
        const lower = command.toLowerCase();
        this.debugLog('Heard: ' + command);

        if (lower.includes('position')) {
          this.handlePositionCommand();
        } else if (lower.includes('find')) {
          this.handleFindCommand(lower);
        } else if (lower.includes('finish')) {
          this.handleFinishCommand();
        } else {
          this.updateStatus('Say: POSITION, FIND [desc], or FINISH');
        }
      }

      handlePositionCommand() {
        if (!this.isInitialized) {
          this.showError('Please initialize first');
          return;
        }
        this.updateStatus('üìç Getting GPS‚Ä¶');
        this.updateVoiceIndicator('processing');

        navigator.geolocation.getCurrentPosition(
          (pos) => {
            this.currentPosition = {
              lat: pos.coords.latitude,
              lng: pos.coords.longitude,
              accuracy: pos.coords.accuracy,
              timestamp: new Date(),
            };
            this.displayCoordinates();
            this.playBeep();
            this.currentStep = 'logged';
            this.updateStatus('‚úÖ Position fixed! Say "FIND [description]"');
            this.updateVoiceIndicator('ready');
          },
          (err) => {
            this.showError('GPS failed: ' + this.getGPSErrorMessage(err));
            this.updateVoiceIndicator('ready');
          },
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
        );
      }

      getGPSErrorMessage(error) {
        switch (error.code) {
          case error.PERMISSION_DENIED:
            return 'Location denied. Enable location in settings.';
          case error.POSITION_UNAVAILABLE:
            return 'GPS unavailable. Move to open area.';
          case error.TIMEOUT:
            return 'GPS timeout. Try again.';
          default:
            return 'GPS error. Check settings.';
        }
      }

      handleFindCommand(command) {
        if (this.currentStep !== 'logged') {
          this.showError('‚ùå Say "POSITION" first');
          return;
        }
        const desc = command.substring(command.indexOf('find') + 4).trim();
        if (!desc) {
          this.updateStatus('Say "FIND" followed by your description');
          return;
        }
        // Save this point + description
        const entry = {
          lat: this.currentPosition.lat,
          lng: this.currentPosition.lng,
          accuracy: this.currentPosition.accuracy,
          timestamp: this.currentPosition.timestamp,
          description: desc,
        };
        this.places.push(entry);

        // Update UI
        this.findTextBoxEl.value = desc;
        this.findSectionEl.style.display = 'block';

        this.currentPosition = null;
        this.currentStep = 'readyToFinish';
        this.updateStatus('‚úÖ Description recorded! Say "FINISH"');
      }

      handleFinishCommand() {
        if (this.places.length === 0) {
          this.showError('‚ùå No points logged yet');
          return;
        }
        this.generateCombinedKML();
        this.currentStep = 'finished';
        this.stopListening();
        this.updateStatus('‚úÖ Generating & downloading cumulative KML‚Ä¶');
        this.downloadKML();
        this.playCompletionTone();
      }

      displayCoordinates() {
        const c = this.currentPosition;
        const text = `Latitude: ${c.lat.toFixed(8)}
Longitude: ${c.lng.toFixed(8)}
Accuracy: ¬±${c.accuracy.toFixed(1)}m
Time: ${c.timestamp.toLocaleString()}`;
        this.coordinatesTextBoxEl.value = text;
        this.coordinatesSectionEl.style.display = 'block';
      }

      generateCombinedKML() {
        const now = new Date();
        const datePrefix = now.toISOString().split('T')[0];
        const timeOfDay = now.toTimeString().split(' ')[0].replace(/:/g, '');
        this.kmlFilename = `${datePrefix}_cumulative_${timeOfDay}.kml`;

        let placemarks = '';
        this.places.forEach((p) => {
          const firstWord = p.description
            .split(' ')[0]
            .replace(/[^a-zA-Z0-9]/g, '') || 'find';
          const timestampStr = p.timestamp.toLocaleString();
          const descriptionEscaped = p.description
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          const tsEscaped = timestampStr
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

          placemarks += `
    <Placemark>
      <name>${firstWord}</name>
      <description>${descriptionEscaped}&#10;${tsEscaped}</description>
      <Point><coordinates>${p.lng},${p.lat},0</coordinates></Point>
    </Placemark>`;
        });

        const kmlContent = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Metal Detector Finds (Cumulative)</name>${placemarks}
  </Document>
</kml>`;

        this.kmlBlob = new Blob([kmlContent], { type: 'application/vnd.google-earth.kml+xml' });
      }

      downloadKML() {
        if (!this.kmlBlob) {
          this.showError('‚ùå No KML to download');
          return;
        }
        const url = URL.createObjectURL(this.kmlBlob);
        const a = document.createElement('a');
        a.href = url;
        a.download = this.kmlFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.showSuccess('üì• Download triggered: ' + this.kmlFilename);
        // We do NOT clear places[], so a later "FINISH" still accumulates all points again.
      }

      /***** NEW KML MERGE FUNCTIONALITY *****/
      async mergeKMLFiles() {
        this.debugLog('üîó Starting KML merge process...');
        
        // Enhanced API support detection
        const hasDirectoryAPI = 'showDirectoryPicker' in window && window.isSecureContext;
        const hasFileAPI = 'showOpenFilePicker' in window && window.isSecureContext;
        
        this.debugLog(`Directory API available: ${hasDirectoryAPI}`);
        this.debugLog(`File API available: ${hasFileAPI}`);
        this.debugLog(`Secure context: ${window.isSecureContext}`);
        this.debugLog(`Protocol: ${window.location.protocol}`);
        
        if (!hasDirectoryAPI && !hasFileAPI) {
          this.showError('‚ùå File System Access API not supported. Requires HTTPS and Chrome/Brave browser.');
          this.debugLog('‚ùå Neither showDirectoryPicker nor showOpenFilePicker available');
          return;
        }

        // Try directory picker first, fallback to file picker
        if (hasDirectoryAPI) {
          await this.mergeFromDirectory();
        } else if (hasFileAPI) {
          await this.mergeFromFileSelection();
        }
      }

      async mergeFromDirectory() {

);
          
          for await (const [name, handle] of directoryHandle.entries()) {
            if (handle.kind === 'file' && filePattern.test(name)) {
              this.debugLog('üìÑ Found matching file: ' + name);
              kmlFiles.push({ name, handle });
            }
          }

          if (kmlFiles.length === 0) {
            this.showError(`‚ùå No matching KML files found for today (${todayDateStr}). Try manual file selection.`);
            this.updateStatus('üí° Tip: Use file picker if files are elsewhere');
            // Offer file picker as alternative
            setTimeout(async () => {
              if (confirm('No auto-detected files found. Select KML files manually?')) {
                await this.mergeFromFileSelection();
              }
            }, 2000);
            return;
          }

          await this.processMergeFiles(kmlFiles, todayDateStr);

        } catch (err) {
          this.debugLog('‚ùå Directory merge error: ' + err.message);
          this.showError('‚ùå Directory access failed: ' + err.message);
          // Fallback to file picker
          await this.mergeFromFileSelection();
        }
      }

      async mergeFromFileSelection() {
        try {
          const today = new Date();
          const todayDateStr = today.toISOString().split('T')[0];
          
          this.updateStatus('üìÅ Select KML files to merge...');
          this.debugLog('üîÑ Using file picker fallback method');
          
          // Use file picker to select multiple KML files
          const fileHandles = await window.showOpenFilePicker({
            multiple: true,
            types: [{
              description: 'KML files',
              accept: {
                'application/vnd.google-earth.kml+xml': ['.kml'],
                'application/xml': ['.kml']
              }
            }]
          });

          if (fileHandles.length === 0) {
            this.updateStatus('‚ùå No files selected');
            return;
          }

          this.debugLog(`‚úÖ Selected ${fileHandles.length} files for merging`);
          
          // Convert file handles to the format expected by processMergeFiles
          const kmlFiles = fileHandles.map(handle => ({
            name: handle.name,
            handle: handle
          }));

          await this.processMergeFiles(kmlFiles, todayDateStr);

        } catch (err) {
          if (err.name === 'AbortError') {
            this.updateStatus('‚ùå File selection cancelled');
            return;
          }
          this.debugLog('‚ùå File selection error: ' + err.message);
          this.showError('‚ùå File selection failed: ' + err.message);
          this.updateStatus('‚úÖ App ready! Awaiting "POSITION"');
        }
      }

      async processMergeFiles(kmlFiles, todayDateStr) {
        try {
          this.showSuccess(`üìä Processing ${kmlFiles.length} KML file(s)`);
          this.updateStatus('üìñ Reading and parsing KML files...');

          // Parse all KML files and extract placemarks
          const allPlacemarks = [];
          
          for (const fileInfo of kmlFiles) {
            try {
              const file = await fileInfo.handle.getFile();
              const content = await file.text();
              const placemarks = this.extractPlacemarksFromKML(content);
              allPlacemarks.push(...placemarks);
              this.debugLog(`‚úÖ Extracted ${placemarks.length} placemarks from ${fileInfo.name}`);
            } catch (err) {
              this.debugLog(`‚ö†Ô∏è Error reading ${fileInfo.name}: ${err.message}`);
            }
          }

          if (allPlacemarks.length === 0) {
            this.showError('‚ùå No valid placemarks found in KML files');
            this.updateStatus('‚úÖ App ready! Awaiting "POSITION"');
            return;
          }

          // Sort placemarks by timestamp if available
          allPlacemarks.sort((a, b) => {
            const timeA = this.extractTimestampFromDescription(a.description);
            const timeB = this.extractTimestampFromDescription(b.description);
            return timeA - timeB;
          });

          // Generate merged KML
          const mergedKML = this.generateMergedKML(allPlacemarks, todayDateStr);
          const mergedFilename = `${todayDateStr}_MERGE.kml`;

          // Download merged KML
          const blob = new Blob([mergedKML], { type: 'application/vnd.google-earth.kml+xml' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = mergedFilename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          this.showSuccess(`üéâ Merged ${allPlacemarks.length} points from ${kmlFiles.length} files into ${mergedFilename}`);
          this.updateStatus('‚úÖ App ready! Awaiting "POSITION"');
          this.playCompletionTone();

        } catch (err) {
          this.debugLog('‚ùå Process merge error: ' + err.message);
          this.showError('‚ùå Merge processing failed: ' + err.message);
          this.updateStatus('‚úÖ App ready! Awaiting "POSITION"');
        }
      }

      extractPlacemarksFromKML(kmlContent) {
        const placemarks = [];
        
        try {
          // Parse XML
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(kmlContent, 'text/xml');
          
          // Check for parsing errors
          const parserError = xmlDoc.querySelector('parsererror');
          if (parserError) {
            this.debugLog('‚ö†Ô∏è XML parsing error: ' + parserError.textContent);
            return placemarks;
          }

          // Extract all Placemark elements
          const placemarkElements = xmlDoc.querySelectorAll('Placemark');
          
          for (const placemark of placemarkElements) {
            const nameEl = placemark.querySelector('name');
            const descEl = placemark.querySelector('description');
            const coordsEl = placemark.querySelector('Point coordinates');
            
            if (coordsEl) {
              const coords = coordsEl.textContent.trim().split(',');
              if (coords.length >= 2) {
                placemarks.push({
                  name: nameEl ? nameEl.textContent.trim() : 'Unknown',
                  description: descEl ? descEl.textContent.trim() : '',
                  longitude: parseFloat(coords[0]),
                  latitude: parseFloat(coords[1]),
                  altitude: coords.length > 2 ? parseFloat(coords[2]) : 0
                });
              }
            }
          }
          
        } catch (err) {
          this.debugLog('‚ö†Ô∏è KML parsing error: ' + err.message);
        }
        
        return placemarks;
      }

      extractTimestampFromDescription(description) {
        // Try to extract timestamp from description
        // Expected format: "description\nMM/DD/YYYY, HH:MM:SS AM/PM"
        const lines = description.split('\n');
        if (lines.length > 1) {
          try {
            return new Date(lines[lines.length - 1]);
          } catch (err) {
            // If parsing fails, return current time
            return new Date();
          }
        }
        return new Date();
      }

      generateMergedKML(placemarks, dateStr) {
        let placemarksXML = '';
        
        placemarks.forEach((p, index) => {
          const nameEscaped = p.name
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          const descEscaped = p.description
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

          placemarksXML += `
    <Placemark>
      <name>${nameEscaped}</name>
      <description>${descEscaped}</description>
      <Point><coordinates>${p.longitude},${p.latitude},${p.altitude}</coordinates></Point>
    </Placemark>`;
        });

        return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>Metal Detector Finds - Merged (${dateStr})</name>
    <description>Merged from ${placemarks.length} finds collected on ${dateStr}</description>${placemarksXML}
  </Document>
</kml>`;
      }

      playBeep() {
        if (!this.audioContext) return;
        try {
          if (this.audioContext.state === 'suspended') this.audioContext.resume();
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          osc.connect(gain);
          gain.connect(this.audioContext.destination);
          osc.frequency.setValueAtTime(800, this.audioContext.currentTime);
          gain.gain.setValueAtTime(0.3, this.audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
          osc.start(this.audioContext.currentTime);
          osc.stop(this.audioContext.currentTime + 0.5);
        } catch (e) {}
      }

      playCompletionTone() {
        if (!this.audioContext) return;
        try {
          if (this.audioContext.state === 'suspended') this.audioContext.resume();
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          osc.connect(gain);
          gain.connect(this.audioContext.destination);
          osc.frequency.setValueAtTime(1200, this.audioContext.currentTime);
          gain.gain.setValueAtTime(0.4, this.audioContext.currentTime);
          osc.start(this.audioContext.currentTime);
          osc.frequency.exponentialRampToValueAtTime(400, this.audioContext.currentTime + 0.3);
          gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
          osc.stop(this.audioContext.currentTime + 0.3);
        } catch (e) {}
      }

      updateStatus(message) {
        this.statusEl.textContent = message;
        this.debugLog('Status: ' + message);
      }

      updateVoiceIndicator(state) {
        this.voiceIndicatorEl.className = `voice-indicator ${state}`;
        if (state === 'listening') {
          this.voiceIndicatorEl.textContent = 'üî¥ Listening‚Ä¶';
        } else if (state === 'processing') {
          this.voiceIndicatorEl.textContent = '‚åõ Processing‚Ä¶';
        } else {
          this.voiceIndicatorEl.textContent = 'üé§ Voice Commands Ready';
        }
      }

      showError(message) {
        const errEl = document.createElement('div');
        errEl.className = 'error';
        errEl.textContent = '‚ùå ' + message;
        this.messagesEl.appendChild(errEl);
        setTimeout(() => {
          if (errEl.parentNode) errEl.parentNode.removeChild(errEl);
        }, 10000);
        this.debugLog('Error: ' + message);
      }

      showSuccess(message) {
        const sucEl = document.createElement('div');
        sucEl.className = 'success';
        sucEl.textContent = '‚úÖ ' + message;
        this.messagesEl.appendChild(sucEl);
        setTimeout(() => {
          if (sucEl.parentNode) sucEl.parentNode.removeChild(sucEl);
        }, 8000);
        this.debugLog('Success: ' + message);
      }

      debugLog(message) {
        if (!this.debugMode) return;
        console.log('[AndroidLogger] ' + message);
        const dbgEl = document.createElement('div');
        dbgEl.className = 'debug';
        dbgEl.textContent = 'üêõ ' + message;
        this.messagesEl.appendChild(dbgEl);
        const logs = this.messagesEl.querySelectorAll('.debug');
        if (logs.length > 5) logs[0].remove();
        setTimeout(() => {
          if (dbgEl.parentNode) dbgEl.parentNode.removeChild(dbgEl);
        }, 8000);
      }

      showAndroidHelp() {
        const hlp = document.createElement('div');
        hlp.className = 'android-help';
        hlp.innerHTML = `
          <h4>ü§ñ Android Tips:</h4>
          <strong>1. Browser:</strong> Use Chrome<br>
          <strong>2. Permissions:</strong><br>
            ‚Ä¢ Chrome Settings ‚Üí Microphone ‚Üí Allow<br>
            ‚Ä¢ Android Settings ‚Üí Chrome ‚Üí Permissions ‚Üí Mic & Location<br>
          <strong>3. Connectivity:</strong> Internet needed for speech recognition<br>
        `;
        this.messagesEl.appendChild(hlp);
        setTimeout(() => {
          if (hlp.parentNode) hlp.parentNode.removeChild(hlp);
        }, 20000);
      }
    }

    // Instantiate on DOMContentLoaded
    let androidLogger;
    document.addEventListener('DOMContentLoaded', () => {
      androidLogger = new AndroidMetalDetectorLogger();
      // Auto-initialization is handled by the constructor
    });
  </script>
</body>
</html>
